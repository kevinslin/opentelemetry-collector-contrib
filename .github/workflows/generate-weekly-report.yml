# This action generates a weekly report as a github issue
# More details in https://github.com/open-telemetry/opentelemetry-collector-contrib/issues/24672

name: 'Generate Weekly Report'
on:
  workflow_dispatch: 
  push:
    branches: [ chore/weekly-report-gen ]

jobs:
  get_issues:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/github-script@v6
        id: get-issues
        with:
          retries: 3
          script: |
            async function getIssues(github, queryParams, filterPrs = true) {
              let allIssues = [];
              try {
                while (true) {
                  const response = await github.issues.listForRepo(queryParams);
                  // filter out pull requests
                  const issues = filterPrs ? response.data.filter(issue => !issue.pull_request) : response.data;
                  allIssues = allIssues.concat(issues);
            
                  // Check the 'link' header to see if there are more pages
                  const linkHeader = response.headers.link;
                  if (!linkHeader || !linkHeader.includes('rel="next"')) {
                    break;
                  }
            
                  queryParams.page++;
                }
                return allIssues;
              } catch (error) {
                console.error('Error fetching issues:', error);
                return [];
              }
            }
            
            function genLookbackDates() {
              const now = new Date();
              const midnightYesterday = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 1);
              const sevenDaysAgo = new Date(midnightYesterday);
              sevenDaysAgo.setDate(midnightYesterday.getDate() - 7);
              return { sevenDaysAgo, midnightYesterday };
            }
            
            function filterOnDateRange({ issue, sevenDaysAgo, midnightYesterday }) {
              const createdAt = new Date(issue.created_at);
              return createdAt >= sevenDaysAgo && createdAt <= midnightYesterday;
            }
            
            async function getNewIssues(github) {
              const { sevenDaysAgo, midnightYesterday } = genLookbackDates();
              const queryParams = {
                owner: 'open-telemetry',
                repo: 'opentelemetry-collector-contrib',
                state: 'all', // To get both open and closed issues
                per_page: 100, // Number of items per page (maximum allowed)
                page: 1, // Start with page 1
                since: sevenDaysAgo.toISOString(),
              };
            
              try {
                const allIssues = await getIssues(github, queryParams)
                const filteredIssues = allIssues.filter(issue => filterOnDateRange({ issue, sevenDaysAgo, midnightYesterday }));
                return filteredIssues;
              } catch (error) {
                console.error('Error fetching issues:', error);
                return [];
              }
            }
            
            async function getTargetLabelIssues(octokit, labels, filterPrs) {
              const queryParams = {
                owner: 'open-telemetry',
                repo: 'opentelemetry-collector-contrib',
                state: 'open',
                per_page: 100, // Number of items per page (maximum allowed)
                page: 1, // Start with page 1
                labels
              };
              try {
                const allIssues = await getIssues(octokit, queryParams, filterPrs)
                return allIssues;
              } catch (error) {
                console.error('Error fetching issues:', error);
                return [];
              }
            }
            
            async function getIssuesData(github) {
              const targetLabels = {
                "needs triage": {
                  filterPrs: true,
                  alias: "issuesTriage",
                },
                "ready to merge": {
                  filterPrs: false,
                  alias: "issuesReadyToMerge",
                },
                "Sponsor Needed": {
                  filterPrs: true,
                  alias: "issuesSponsorNeeded",
                },
              };
            
              const issuesNew = await getNewIssues(github.rest);
              const issuesWithLabels = {};
              for (const lbl of Object.keys(targetLabels)) {
                const filterPrs = targetLabels[lbl].filterPrs;
                const resp = await getTargetLabelIssues(github.rest, lbl, filterPrs);
                issuesWithLabels[lbl] = resp;
              }
            
              // tally results
              const stats = {
                issuesNew: {
                  title: "New issues",
                  count: 0,
                  data: []
                },
                issuesTriage: {
                  title: "Issues needing triage",
                  count: 0,
                  data: []
                },
                issuesReadyToMerge: {
                  title: "Issues ready to merge",
                  count: 0,
                  data: []
                },
                issuesSponsorNeeded: {
                  title: "Issues needing sponsorship",
                  count: 0,
                  data: []
                },
                issuesNewSponsorNeeded: {
                  title: "New issues needing sponsorship",
                  count: 0,
                  data: []
                },
              }
            
              // add new issues
              issuesNew.forEach(issue => {
                stats.issuesNew.count++;
                const { url, title, number } = issue;
                stats.issuesNew.data.push({ url, title, number });
              });
            
              // add issues with labels
              for (const lbl of Object.keys(targetLabels)) {
                const alias = targetLabels[lbl].alias;
                stats[alias].count = issuesWithLabels[lbl].length;
                stats[alias].data = issuesWithLabels[lbl].map(issue => {
                  const { url, title, number } = issue;
                  return { url, title, number };
                })
              }
            
              // add new issues with sponsor needed label
              const { sevenDaysAgo, midnightYesterday } = genLookbackDates();
              const sponsorNeededIssues = issuesWithLabels["Sponsor Needed"].filter(issue => filterOnDateRange({ issue, sevenDaysAgo, midnightYesterday }));
              sponsorNeededIssues.forEach(issue => {
                stats.issuesNewSponsorNeeded.count++;
                const { url, title, number } = issue;
                stats.issuesNewSponsorNeeded.data.push({ url, title, number });
              });
              return stats
            }
            
            function generateReport({ issuesData, previousReport }) {
              const out = [
                `## Format`,
                "- `{CATEGORY}: {COUNT} ({CHANGE_FROM_PREVIOUS_WEEK})`",
                "## Report",
                '<ul>'];
            
              for (const lbl of Object.keys(issuesData)) {
                const section = [``];
                const { count, data, title } = issuesData[lbl];
                const previousCount = previousReport.issuesData[lbl].count;
                section.push(`<li> ${title}: ${count} (${count - previousCount})`);
            
                // generate summary if issues exist
                if (data.length !== 0) {
                  section.push(`<details>
                <summary> Issues </summary>
                <ul>
                ${data.map((issue) => {
                    const { url, title, number } = issue;
                    return `<li><a href="${url}">#${number}</a> ${title}</li>`;
                  }).join('\n')}
                </ul>
            </details>`);
                }
            
                section.push('</li>');
                out.push(section.join('\n'));
              }
            
              out.push('</ul>');
            
              // add json data
              out.push('\n ## JSON Data');
              out.push('<!-- MACHINE GENERATED: DO NOT EDIT -->');
              out.push(`<details>
            <summary>Expand</summary>
            <pre>
            {
              "issuesData": ${JSON.stringify(issuesData, null, 2)}
            }
            </pre>
            </details>`);
              const report = out.join('\n');
              return report;
            }
            
            async function createIssue({ github, lookbackData, report, context }) {
              const title = `Weekly Report: ${lookbackData.sevenDaysAgo.toISOString().slice(0, 10)} - ${lookbackData.midnightYesterday.toISOString().slice(0, 10)}`;
              return github.rest.issues.create({
                // TODO: change
                owner: context.repository_owner,
                repo: "opentelemetry-collector-contrib",
                title,
                body: report,
                labels: ["report"]
              })
            }
            
            async function getLastWeeksReport({ github, since, context }) {
              const issues = await github.rest.issues.listForRepo({
                owner: context.repository_owner,
                repo: 'opentelemetry-collector-contrib',
                state: 'all', // To get both open and closed issues
                labels: ["report"],
                since: since.toISOString(),
                per_page: 1,
                direction: "asc"
              });
              if (issues.data.length === 0) {
                throw new Error("no report found since " + since.toISOString());
              } 
              // grab earliest issue if multiple
              return issues.data[0];
            }
            
            function parseJsonFromText(text) {
              // Use regex to find the JSON data within the <pre></pre> tags
              const regex = /<pre>\s*([\s\S]*?)\s*<\/pre>/;
              const match = text.match(regex);
            
              if (match && match[1]) {
                // Parse the found string to JSON
                return JSON.parse(match[1]);
              } else {
                throw new Error("JSON data not found");
              }
            }
            
            async function main({ github, context }) {
              const lookbackData = genLookbackDates();
              const issuesData = await getIssuesData(github);
            
              // BEGIN_DEBUG
              // writeJSONSync('./fixtures/lastweek-issues.json', issuesData);
              // issuesData = readJSONSync('./fixtures/lastweek-issues.json')
              // END_DEBUG
            
            
              const prevReportLookback = new Date(lookbackData.sevenDaysAgo)
              prevReportLookback.setDate(prevReportLookback.getDate() - 7)
              const previousReportIssue = await getLastWeeksReport({github, since: prevReportLookback, context});
              const {created_at, id, url, title} = previousReportIssue;
              debug({ msg: "previous issue", created_at, id, url, title })
            
              // BEGIN_DEBUG
              // previousReportIssue = JSON.parse(fs.readFileSync("./fixtures/issues.json", "utf8"))
              // END_DEBUG
            
              const previousReport = parseJsonFromText(previousReportIssue.body)
              // debug({ issuesData, previousReport })
            
              const report = generateReport({ issuesData, previousReport })
            
              // BEGIN_DEBUG
              // fs.writeFileSync('./fixtures/report.2.md', report);
              // END_DEBUG
              await createIssue({github, lookbackData, report, context});
            }
            
            function debug(msg) {
              console.log(JSON.stringify(msg, null, 2))
            }
            
            function readJSONSync(path) {
              return JSON.parse(fs.readFileSync(path, 'utf8'))
            }
            
            function writeJSONSync(path, data) {
              fs.writeFileSync(path, JSON.stringify(data, null, 2));
            }
            
            
            await main({github, context})