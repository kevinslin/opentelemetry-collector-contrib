# This action generates a weekly report as a github issue
# More details in https://github.com/open-telemetry/opentelemetry-collector-contrib/issues/24672

name: 'Generate Weekly Report'
on:
  workflow_dispatch: 
  push:
    branches: [ main ]

jobs:
  get_issues:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v6
        id: get-issues
        with:
          retries: 3
          script: |
            async function getIssues(github, queryParams, filterPrs = true) {
              let allIssues = [];
              try {
                while (true) {
                  const response = await github.issues.listForRepo(queryParams);
                  // filter out pull requests
                  const issues = filterPrs ? response.data.filter(issue => !issue.pull_request) : response.data;
                  allIssues = allIssues.concat(issues);
            
                  // Check the 'link' header to see if there are more pages
                  const linkHeader = response.headers.link;
                  if (!linkHeader || !linkHeader.includes('rel="next"')) {
                    break;
                  }
            
                  queryParams.page++;
                }
                return allIssues;
              } catch (error) {
                console.error('Error fetching issues:', error);
                return [];
              }
            }
            
            function genLookbackDates() {
              const now = new Date();
              const midnightYesterday = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 1);
              const sevenDaysAgo = new Date(midnightYesterday);
              sevenDaysAgo.setDate(midnightYesterday.getDate() - 7);
              return { sevenDaysAgo, midnightYesterday };
            }
            
            function filterOnDateRange({ issue, sevenDaysAgo, midnightYesterday }) {
              const createdAt = new Date(issue.created_at);
              return createdAt >= sevenDaysAgo && createdAt <= midnightYesterday;
            }
            
            async function getNewIssues(github) {
              const { sevenDaysAgo, midnightYesterday} = genLookbackDates();
              const queryParams = {
                owner: 'open-telemetry',
                repo: 'opentelemetry-collector-contrib',
                state: 'all', // To get both open and closed issues
                per_page: 100, // Number of items per page (maximum allowed)
                page: 1, // Start with page 1
                since: sevenDaysAgo.toISOString(),
              };
            
              try {
                const allIssues = await getIssues(github, queryParams)
                const filteredIssues = allIssues.filter(issue => filterOnDateRange({ issue, sevenDaysAgo, midnightYesterday }));
                return filteredIssues;
              } catch (error) {
                console.error('Error fetching issues:', error);
                return [];
              }
            }
            
            async function getTargetLabelIssues(octokit, labels, filterPrs) {
              const queryParams = {
                owner: 'open-telemetry',
                repo: 'opentelemetry-collector-contrib',
                state: 'open',
                per_page: 100, // Number of items per page (maximum allowed)
                page: 1, // Start with page 1
                labels
              };
              try {
                const allIssues = await getIssues(octokit, queryParams, filterPrs)
                return allIssues;
              } catch (error) {
                console.error('Error fetching issues:', error);
                return [];
              }
            }
            
            const targetLabels = {
              "needs triage": {
                filterPrs: true,
                alias: "issuesTriage",
              },
              "ready to merge": {
                filterPrs: false,
                alias: "issuesReadyToMerge",
              },
              "Sponsor Needed": {
                filterPrs: true,
                alias: "issuesSponsorNeeded",
              },
            };
          
            const issuesNew = await getNewIssues(github.rest);
            const issuesWithLabels = {};
            for (const lbl of Object.keys(targetLabels)) {
              const filterPrs = targetLabels[lbl].filterPrs;
              const resp = await getTargetLabelIssues(github.rest, lbl, filterPrs);
              issuesWithLabels[lbl] = resp;
            }
          
            // tally results
            const stats = {
              issuesNew: {
                count: 0,
                data: []
              },
              issuesTriage: {
                count: 0,
                data: []
              },
              issuesReadyToMerge: {
                count: 0,
                data: []
              },
              issuesSponsorNeeded: {
                count: 0,
                data: []
              },
              issuesNewSponsorNeeded: {
                count: 0,
                data: []
              },
            }
          
            // add new issues
            issuesNew.forEach(issue => {
              stats.issuesNew.count++;
              const { url, title, number } = issue;
              stats.issuesNew.data.push({ url, title, number });
            });
          
            // add issues with labels
            for (const lbl of Object.keys(targetLabels)) {
              const alias = targetLabels[lbl].alias;
              stats[alias].count = issuesWithLabels[lbl].length;
              stats[alias].data = issuesWithLabels[lbl].map(issue => {
                const { url, title, number } = issue;
                return { url, title, number };
              })
            }
          
            // add new issues with sponsor needed label
            const {sevenDaysAgo, midnightYesterday} = genLookbackDates();
            const sponsorNeededIssues = issuesWithLabels["Sponsor Needed"].filter(issue => filterOnDateRange({ issue, sevenDaysAgo, midnightYesterday }));
            sponsorNeededIssues.forEach(issue => {
              stats.issuesNewSponsorNeeded.count++;
              const { url, title, number } = issue;
              stats.issuesNewSponsorNeeded.data.push({ url, title, number });
            });
            return stats;
      - name: Get result
        run: echo "${{steps.get-issues.outputs.result}}"